use 5.010;
use strict;
use warnings;

use Test::More;

=pod translation use case
    2 + 3                         -- infix
    
    (+ 2 3)                       -- prefix
  
    (2 3 +)                       -- postfix
  
    bipush 2                      -- JVM 
    bipush 3 
    iadd 
  
    the sum of 2 and 3            -- English
    -- http://www.cse.chalmers.se/edu/year/2012/course/DAT150/lectures/proglang-02.html
=cut

use Marpa::R2;

use Data::Dumper;
$Data::Dumper::Indent = 0;
$Data::Dumper::Terse = 1;

my $tests = [
    #    2 + 3                         -- infix
    [   
        'infix',
        [ '2 + 3', '2 * 3' ],
        q{
            e ::= int plus int # | int star int
            int  ~ [\d]   
            plus ~ '+'
#            star ~ '*'
        }
    ],
    #    (+ 2 3)                       -- prefix
    [   
        'prefix',
        [ '(+ 2 3)', '(* 2 3)' ],
        q{
            e ::= '(' plus int int ')' #| '(' star int int ')' 
            int  ~ [\d]   
            plus ~ '+'
#            star ~ '*'
        }
    ],
    #    (2 3 +)                       -- postfix
    [   
        'postfix',
        [ '(2 3 +)', '(2 3 *)' ],
        q{
            e ::= '(' int int plus ')' # | '(' int int star ')'
            int  ~ [\d]   
            plus ~ '+'
#            star ~ '*'
        }
    ],
    #    bipush 2                      -- JVM 
    #    bipush 3 
    #    iadd 
    [   
        'JVM',
        [
            q{
                bipush 2
                bipush 3
                iadd 
            },
            q{
                bipush 2
                bipush 3
                imul 
            },
        ],
        q{
            e ::= push push add # | push push mul
            push ::= 'bipush' int
            int  ~ [\d]
            add  ~ 'iadd'
#            mul  ~ 'imul'
        }
    ],
    #    the sum of 2 and 3            -- English
    [   
        'English',
        [ 'the sum of 2 and 3', 'the product of 2 and 3' ],
        q{
            e ::= 'the' op 'of' int 'and' int
            op ~ 'sum' # | 'product'
            int  ~ [\d]
        }
    ],
];


my $grammar_prolog = q{
    :default ::= action => [lhs, values]
    lexeme default = action => [lhs, values]
};

my $grammar_epilog = q{
    :discard ~ whitespace
    whitespace ~ [\s+]
};

#
# translation tables
# source_id => { target_id => { lhs1 => ast2 } }
# for this trivial case, a rule is uniquely identified by its lhs, hence lhs1
# -- trivial, but that's a start before rule array descriptor is implemented
# source_id => { target_id => { rule1 => ast2 } }
#
my $tt = &tree_transducer_generate( $tests );

#
# Generating a translation table (tree transducer) needs g1, g2, and
# pairs of inputs for each alternative of each rhs (i.e. rule_id)
# lexeme inputs can be added or generated by using 
# custom :start symbol feature of 
# 
sub tree_transducer_generate{
    my ($tests) = @_;
    my $trees = {};
    for my $test (@$tests){
        my ($name, $inputs, $grammar_source) = @$test;
        $grammar_source = $grammar_prolog . $grammar_source . $grammar_epilog;
        my $g = Marpa::R2::Scanless::G->new( { source  => \$grammar_source } );
        for my $input (@$inputs){
            # parse input string
            my $r = Marpa::R2::Scanless::R->new( { grammar => $g } );
            warn "# input:\n", $input;
            $r->read( \$input );
            # process the ast
            my $ast = ${ $r->value() };
#            warn "# Dumper'ed ast\n",  Dumper $ast;
            ast_ids_to_lhs($g, $ast);
#            warn "# lhs-ed ast\n",  Dumper $ast;
            $trees->{$name}->{$input} = $ast;
            last; # lhs-only
        }
    }
    warn "# trees\n", Dumper $trees;
}

#
# replace IDs to LHS's in $ast based on grammar $g
#
sub ast_ids_to_lhs{
    my ($g, $ast) = @_;
    if (ref $ast){
        my ($id, @nodes) = @$ast;
        $ast->[0] = $g->symbol_display_form($id);
        map { ast_ids_to_lhs($g, $_) } @nodes unless @nodes == 1 and ref $nodes[0] eq "SCALAR";
    }
}

#
# each lhs on the newline indented in 2-space increments
# lexeme values on the same line
# literals in single quotes ''
# 
sub ast_show{
    my ($ast) = @_;
    state $depth++;
    my $indent = "  " x ($depth - 1);
    if (ref $ast){
        my ($lhs, @nodes) = @$ast;
        if (@nodes == 1 and not ref $nodes[0]){
            warn $indent, "$lhs: '$nodes[0]'";
        }
        else{
            warn $indent, "$lhs: ";
            map { ast_show( $_ ) } @nodes;
        }
    }
    else{
        warn $indent, "'$ast'";
    }
    $depth--;
    return;
}

#
# translate $ast based on translation table $t 
#
sub ast_translate {
    my ($ast, $t) = @_;
    warn "# Translating:\n", Dumper $ast;
    warn "# based on\n", Dumper $t;
    # extract start rule and its translation
    my ($lhs, @nodes) = @$ast;
    my $r1 = $ast;
    my $r2 = $t->{$lhs} or warn "Can't find translation for lhs $lhs";
    # translate start rule recursing as needed
    return rule_rewrite($r1, $r2, $t);
}

#
# rewrite rule $r1 into $r2 based on table $t recursing as needed 
#
sub rule_rewrite {
    my ($r1, $r2, $t) = @_;
    state $depth++;
    my $indent = "  " x ($depth - 1);
    
    $depth--;
}

#
# generate string $s from $ast
#
sub ast_derive{
    my ($ast) = @_;
    my $s;
    state $depth++;
    my $indent = "  " x ($depth - 1);
    if (ref $ast){
        my ($lhs, @nodes) = @$ast;
        if (@nodes == 1 and not ref $nodes[0]){ # lexeme
            $s .= $nodes[0];
        }
        else{
            $s .= join ' ', map { ast_derive( $_ ) } @nodes;
        }
    }
    else{ # scalar rule value
        $s .= $ast;
    }
    $depth--;
    return $s;
}

=pod
    translation table
    
    rule_id
    r1_id => r2_id
    context-free grammars
        trivial prioritized rules (with only one alternatives) can be related by having the same name
    
=cut

for my $test (@$tests){
    my ($name, $inputs, $grammar_source) = @$test;
    warn "#\n# $name\n#";
#    warn $grammar_source;
    $grammar_source = $grammar_prolog . $grammar_source . $grammar_epilog;
    my $g = Marpa::R2::Scanless::G->new( { source  => \$grammar_source } );
#    warn $g->show_rules(1, 'G1');
#    warn $g->show_rules(1, 'L0');
    for my $input (@$inputs){

        # parse input string
        my $r = Marpa::R2::Scanless::R->new( { grammar => $g } );
        warn "# input:\n", $input;
        $r->read( \$input );
        # process the ast
        my $ast = ${ $r->value() };
#        warn "# Dumper'ed ast\n",  Dumper $ast;
        ast_ids_to_lhs($g, $ast);
#        warn "# ast"; ast_show( $ast );
        
        # generate string from ast (reproduce input)
        my $s = ast_derive( $ast );
        $r = Marpa::R2::Scanless::R->new( { grammar => $g } );
        $r->read( \$s );
        my $s_ast = ${ $r->value() };
        ast_ids_to_lhs($g, $s_ast);
        
        is_deeply($s_ast, $ast, "ast from generated string");
#        warn "# s\n$s";
        
        # translate input
        ast_translate( $ast, $tt->{$name}->{'prefix'} );
        
        last; # only the first input for now
    }
    last; # only infix => prefix for now
}

done_testing();
